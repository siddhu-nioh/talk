// Load env in non-prod
if (process.env.NODE_ENV !== "production") {
  require("dotenv").config();
}

const path = require("path");
const express = require("express");
const mongoose = require("mongoose");
const cors = require("cors");
const http = require("http");
const { Server } = require("socket.io");

// Routes & Models
const userRoutes = require("./routes/user");
const talkRoutes = require("./routes/talk");
const chatRoutes = require("./routes/chat");
const Conversation = require("./models/Conversation");

// App and HTTP server
const app = express();
const server = http.createServer(app);

// CORS: keep Express and Socket.IO aligned
const ALLOWED_ORIGINS = [
  "http://localhost:5173",
  "https://www.thetalk.org.in",
];

// Socket.IO attached to the HTTP server
const io = new Server(server, {
  cors: {
    origin: ALLOWED_ORIGINS,
    credentials: true,
    methods: ["GET", "POST"],
  },
  transports: ["websocket", "polling"],
});

// Make io/users accessible where needed (optional)
global.io = io;
global.users = {}; // userId -> socketId

// Socket.IO events
io.on("connection", (socket) => {
  console.log("🔗 WebSocket connected:", socket.id);

  socket.on("userOnline", (userId) => {
    if (!userId) return;
    global.users[userId] = socket.id;
    console.log(`✅ User ${userId} online as ${socket.id}`);
    socket.broadcast.emit("userStatusChange", { userId, status: "online" });
  });

  socket.on("sendMessage", async ({ senderId, receiverId, content, mediaType, mediaUrl }) => {
    try {
      let conversation = await Conversation.findOne({
        participants: { $all: [senderId, receiverId] },
      });

      const newMessage = {
        sender: senderId,
        text: content,
        status: "sent",
      };

      if (mediaType && mediaUrl) {
        newMessage.media = { type: mediaType, url: mediaUrl };
      }

      if (!conversation) {
        conversation = new Conversation({
          participants: [senderId, receiverId],
          messages: [newMessage],
          userStatus: [
            { user: senderId, status: "active", lastRead: new Date() },
            { user: receiverId, status: "active", lastRead: null },
          ],
        });
      } else {
        conversation.messages.push(newMessage);

        const senderStatus = conversation.userStatus.find(
          (s) => s.user.toString() === senderId.toString()
        );
        if (senderStatus) {
          senderStatus.lastRead = new Date();
          senderStatus.status = "active";
        } else {
          conversation.userStatus.push({
            user: senderId,
            status: "active",
            lastRead: new Date(),
          });
        }

        const receiverStatus = conversation.userStatus.find(
          (s) => s.user.toString() === receiverId.toString()
        );
        if (!receiverStatus) {
          conversation.userStatus.push({
            user: receiverId,
            status: "active",
            lastRead: null,
          });
        } else if (receiverStatus.status === "deleted") {
          receiverStatus.status = "active";
        }
      }

      await conversation.save();

      const newMessageObj = conversation.messages[conversation.messages.length - 1];

      // Notify receiver if online
      if (global.users[receiverId]) {
        io.to(global.users[receiverId]).emit("newMessage", {
          senderId,
          content,
          mediaType: mediaType || null,
          mediaUrl: mediaUrl || null,
          messageId: newMessageObj._id,
          conversationId: conversation._id,
          timestamp: newMessageObj.timestamp,
          status: newMessageObj.status,
        });

        // Auto-mark delivered if receiver socket active
        newMessageObj.status = "delivered";
        await conversation.save();

        console.log(`📩 Delivered to ${receiverId}:`, content);
      }

      // Confirm to sender
      if (global.users[senderId]) {
        io.to(global.users[senderId]).emit("messageSent", {
          receiverId,
          messageId: newMessageObj._id,
          conversationId: conversation._id,
          timestamp: newMessageObj.timestamp,
          status: newMessageObj.status,
        });
      }
    } catch (error) {
      console.error("❌ WebSocket message error:", error);
      if (senderId && global.users[senderId]) {
        io.to(global.users[senderId]).emit("messageError", {
          error: "Failed to deliver message",
          receiverId,
        });
      }
    }
  });

  socket.on("typing", ({ senderId, receiverId, isTyping }) => {
    if (global.users[receiverId]) {
      io.to(global.users[receiverId]).emit("userTyping", { senderId, isTyping });
    }
  });

  socket.on("messageRead", async ({ senderId, receiverId, conversationId }) => {
    try {
      const conversation = await Conversation.findById(conversationId);
      if (!conversation) return;

      const receiverStatus = conversation.userStatus.find(
        (s) => s.user.toString() === receiverId.toString()
      );
      if (receiverStatus) {
        receiverStatus.lastRead = new Date();
      } else {
        conversation.userStatus.push({
          user: receiverId,
          status: "active",
          lastRead: new Date(),
        });
      }

      let updated = false;
      conversation.messages.forEach((m) => {
        if (m.sender.toString() === senderId.toString() && m.status !== "read") {
          m.status = "read";
          updated = true;
        }
      });

      if (updated) {
        await conversation.save();
        if (global.users[senderId]) {
          io.to(global.users[senderId]).emit("messagesRead", {
            readBy: receiverId,
            conversationId,
          });
        }
      }
    } catch (error) {
      console.error("Error updating read status:", error);
    }
  });

  socket.on("messagesDelivered", async ({ senderId, receiverId, conversationId }) => {
    try {
      const conversation = await Conversation.findById(conversationId);
      if (!conversation) return;

      let updated = false;
      conversation.messages.forEach((m) => {
        if (m.sender.toString() === senderId.toString() && m.status === "sent") {
          m.status = "delivered";
          updated = true;
        }
      });

      if (updated) {
        await conversation.save();
        if (global.users[senderId]) {
          io.to(global.users[senderId]).emit("messagesDelivered", {
            deliveredTo: receiverId,
            conversationId,
          });
        }
      }
    } catch (error) {
      console.error("Error updating delivery status:", error);
    }
  });

  socket.on("enterConversation", async ({ userId, conversationId }) => {
    try {
      const conversation = await Conversation.findById(conversationId);
      if (!conversation) return;

      const otherUserId = conversation.participants.find(
        (p) => p.toString() !== userId.toString()
      );

      if (otherUserId && global.users[otherUserId]) {
        io.to(global.users[otherUserId]).emit("userInConversation", {
          userId,
          conversationId,
          status: "active",
        });
      }

      socket.join(`conversation-${conversationId}`);
    } catch (error) {
      console.error("Error on enterConversation:", error);
    }
  });

  socket.on("leaveConversation", ({ userId, conversationId }) => {
    try {
      socket.broadcast
        .to(`conversation-${conversationId}`)
        .emit("userLeftConversation", {
          userId,
          conversationId,
          status: "inactive",
        });
      socket.leave(`conversation-${conversationId}`);
    } catch (error) {
      console.error("Error on leaveConversation:", error);
    }
  });

  socket.on("disconnect", () => {
    console.log("❌ Disconnected:", socket.id);
    const userId = Object.keys(global.users).find((k) => global.users[k] === socket.id);
    if (userId) {
      delete global.users[userId];
      socket.broadcast.emit("userStatusChange", { userId, status: "offline" });
    }
  });
});

// Express middleware (order matters)
app.use(
  cors({
    origin: ALLOWED_ORIGINS,
    credentials: true,
    methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allowedHeaders: ["Content-Type", "Authorization"],
  })
);
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Views only if needed for a few pages (optional)
app.set("view engine", "ejs");
app.set("views", path.join(__dirname, "views"));

// Health check and root
app.get("/", (req, res) => {
  res.send("Welcome to the Talk API!");
});

// Routes
app.use("/", userRoutes);
app.use("/talk", talkRoutes);
app.use("/chat", chatRoutes);

// Single, unified error handler (JSON)
app.use((err, req, res, next) => {
  console.error(err.stack);
  const status = err.status || 500;
  res.status(status).json({
    message: err.message || "Internal server error",
  });
});

// Database and server start
const PORT = process.env.PORT || 8080;
mongoose
  .connect(process.env.ATLASDB_URL)
  .then(() => {
    console.log("Connected to DB");
    server.listen(PORT, () => {
      console.log(`Server listening on ${PORT}`);
    });
  })
  .catch((err) => {
    console.error("Database connection error:", err);
    process.exit(1);
  });
